{"version":3,"sources":["../node_modules/nanoid/index.browser.js","components/ContactForm/ContactForm.jsx","components/ContactList/ContactList.jsx","components/ContactItem/ContactItem.jsx","components/Filter/Filter.jsx","views/ContactsView.js"],"names":["nanoid","size","id","bytes","crypto","getRandomValues","Uint8Array","byte","toString","toUpperCase","ContactForm","state","name","number","loginInputNameId","loginInputNamberId","hendleInputChange","event","currentTarget","value","setState","handleSubmit","preventDefault","props","items","some","contact","alert","onSubmit","reset","this","className","htmlFor","type","pattern","title","required","onChange","Component","connect","getItems","dispatch","addContact","ContactList","children","contactsItems","getFilteredContactList","onDelete","deleteContact","map","onClick","getFilterValue","changeFilter","target","ContactsView","fetchItems","length","isLoading","getLoadingItems","fetchContacts"],"mappings":"gOAiCA,IA2CIA,EAAS,WAKX,IAL0B,IAAdC,EAAc,uDAAP,GACfC,EAAK,GACLC,EAAQC,OAAOC,gBAAgB,IAAIC,WAAWL,IAG3CA,KAAQ,CAMb,IAAIM,EAAqB,GAAdJ,EAAMF,GAGfC,GAFEK,EAAO,GAEHA,EAAKC,SAAS,IACXD,EAAO,IAETA,EAAO,IAAIC,SAAS,IAAIC,cACtBF,EAAO,GACV,IAEA,IAGV,OAAOL,G,OC9FHQ,E,4MAMJC,MAAQ,CACNC,KAAM,GACNC,OAAQ,I,EAGVC,iBAAmBd,I,EACnBe,mBAAqBf,I,EAErBgB,kBAAoB,SAAAC,GAClB,MAAwBA,EAAMC,cAAtBN,EAAR,EAAQA,KAAMO,EAAd,EAAcA,MAEd,EAAKC,SAAL,eAAiBR,EAAOO,K,EAG1BE,aAAe,SAAAJ,GACbA,EAAMK,iBAKF,EAAKC,MAAMC,MAAMC,MAHC,SAAAC,GAAO,OAC3BA,EAAQd,OAAS,EAAKD,MAAMC,MAAQc,EAAQb,SAAW,EAAKF,MAAME,UAGlEc,MAAM,mCAIR,EAAKJ,MAAMK,SAAX,eAAwB,EAAKjB,QAC7B,EAAKkB,U,EAGPA,MAAQ,WACN,EAAKT,SAAS,CAAER,KAAM,GAAIC,OAAQ,M,4CAGpC,WACE,MAAyBiB,KAAKnB,MAAtBC,EAAR,EAAQA,KAAMC,EAAd,EAAcA,OAEd,OACE,yBAASkB,UAAU,sBAAnB,SACE,uBAAMH,SAAYE,KAAKT,aAAvB,UACE,uBAAOW,QAASF,KAAKhB,iBAArB,kBAEA,uBACEmB,KAAK,OACLrB,KAAK,OACLsB,QAAQ,yHACRC,MAAM,kcACNC,UAAQ,EACRlC,GAAM4B,KAAKhB,iBACXK,MAAOP,EACPyB,SAAYP,KAAKd,oBAKnB,uBAAOgB,QAASF,KAAKf,mBAArB,oBAEA,uBACEkB,KAAK,MACLrB,KAAK,SACLsB,QAAQ,yFACRC,MAAM,6iBACNC,UAAQ,EACRlC,GAAM4B,KAAKf,mBACXI,MAAON,EACPwB,SAAYP,KAAKd,oBAInB,wBAAQiB,KAAK,SAASF,UAAU,cAAhC,kC,GA1EgBO,aA0FXC,eARS,SAAA5B,GAAK,MAAK,CAChCa,MAAOgB,YAAS7B,OAGW,SAAA8B,GAAQ,MAAK,CACxCb,SAAU,gBAAGhB,EAAH,EAAGA,KAAMC,EAAT,EAASA,OAAT,OAAsB4B,EAASC,YAAW,CAAE9B,OAAMC,gBAG/C0B,CAA+C7B,GCtF/CiC,EARK,SAAC,GAAD,IAAGC,EAAH,EAAGA,SAAH,OAClB,oBAAIb,UAAU,cAAd,SAA6Ba,KCwBhBL,eARS,SAAA5B,GAAK,MAAK,CAChCkC,cAAeC,YAAuBnC,OAGX,SAAA8B,GAAQ,MAAK,CACxCM,SAAU,SAAA7C,GAAE,OAAIuC,EAASO,YAAc9C,QAG1BqC,EAvBK,SAAC,GAAD,IAAGQ,EAAH,EAAGA,SAAUF,EAAb,EAAaA,cAAb,OAClB,mCACGA,EAAcI,KAAI,YAA2B,IAAxB/C,EAAuB,EAAvBA,GAAIU,EAAmB,EAAnBA,KAAMC,EAAa,EAAbA,OAC9B,OACE,+BACE,sCAAOD,EAAP,aAAgBC,KAChB,wBAAQoB,KAAK,SAASiB,QAAS,kBAAMH,EAAS7C,IAAK6B,UAAU,MAA7D,sBAFO7B,WCaFqC,eARS,SAAA5B,GAAK,MAAK,CAChCQ,MAAOgC,YAAexC,OAGK,SAAA8B,GAAQ,MAAK,CACxCJ,SAAU,SAAApB,GAAK,OAAIwB,EAASW,YAAanC,EAAMoC,OAAOlC,YAGzCoB,EAlBA,SAAC,GAAD,IAAGpB,EAAH,EAAGA,MAAOkB,EAAV,EAAUA,SAAV,OACb,wBAAON,UAAU,SAAjB,kCAEE,8BACE,uBAAOE,KAAK,OAAOd,MAAOA,EAAOkB,SAAUA,Y,gBCI3CiB,E,uKACJ,WACExB,KAAKP,MAAMgC,e,oBAGb,WACE,OACE,qCACE,2CACA,cAAC,EAAD,IACA,0CAECzB,KAAKP,MAAMC,MAAMgC,OAAS,EACzB,qCACE,cAAC,EAAD,IACA,cAAC,EAAD,UACE,cAAC,EAAD,SAIJ,gE,GApBiBlB,aAqCZC,uBATS,SAAA5B,GAAK,MAAK,CAChCa,MAAOgB,YAAS7B,GAChB8C,UAAWC,YAAgB/C,OAGF,SAAA8B,GAAQ,MAAK,CACtCc,WAAY,kBAAMd,EAASkB,mBAGdpB,CAA6Ce","file":"static/js/contacts-view.d750bea6.chunk.js","sourcesContent":["// This file replaces `index.js` in bundlers like webpack or Rollup,\n// according to `browser` config in `package.json`.\n\nimport { urlAlphabet } from './url-alphabet/index.js'\n\nif (process.env.NODE_ENV !== 'production') {\n  // All bundlers will remove this block in the production bundle.\n  if (\n    typeof navigator !== 'undefined' &&\n    navigator.product === 'ReactNative' &&\n    typeof crypto === 'undefined'\n  ) {\n    throw new Error(\n      'React Native does not have a built-in secure random generator. ' +\n        'If you don’t need unpredictable IDs use `nanoid/non-secure`. ' +\n        'For secure IDs, import `react-native-get-random-values` ' +\n        'before Nano ID.'\n    )\n  }\n  if (typeof msCrypto !== 'undefined' && typeof crypto === 'undefined') {\n    throw new Error(\n      'Import file with `if (!window.crypto) window.crypto = window.msCrypto`' +\n        ' before importing Nano ID to fix IE 11 support'\n    )\n  }\n  if (typeof crypto === 'undefined') {\n    throw new Error(\n      'Your browser does not have secure random generator. ' +\n        'If you don’t need unpredictable IDs, you can use nanoid/non-secure.'\n    )\n  }\n}\n\nlet random = bytes => crypto.getRandomValues(new Uint8Array(bytes))\n\nlet customRandom = (alphabet, size, getRandom) => {\n  // First, a bitmask is necessary to generate the ID. The bitmask makes bytes\n  // values closer to the alphabet size. The bitmask calculates the closest\n  // `2^31 - 1` number, which exceeds the alphabet size.\n  // For example, the bitmask for the alphabet size 30 is 31 (00011111).\n  // `Math.clz32` is not used, because it is not available in browsers.\n  let mask = (2 << (Math.log(alphabet.length - 1) / Math.LN2)) - 1\n  // Though, the bitmask solution is not perfect since the bytes exceeding\n  // the alphabet size are refused. Therefore, to reliably generate the ID,\n  // the random bytes redundancy has to be satisfied.\n\n  // Note: every hardware random generator call is performance expensive,\n  // because the system call for entropy collection takes a lot of time.\n  // So, to avoid additional system calls, extra bytes are requested in advance.\n\n  // Next, a step determines how many random bytes to generate.\n  // The number of random bytes gets decided upon the ID size, mask,\n  // alphabet size, and magic number 1.6 (using 1.6 peaks at performance\n  // according to benchmarks).\n\n  // `-~f => Math.ceil(f)` if f is a float\n  // `-~i => i + 1` if i is an integer\n  let step = -~((1.6 * mask * size) / alphabet.length)\n\n  return () => {\n    let id = ''\n    while (true) {\n      let bytes = getRandom(step)\n      // A compact alternative for `for (var i = 0; i < step; i++)`.\n      let j = step\n      while (j--) {\n        // Adding `|| ''` refuses a random byte that exceeds the alphabet size.\n        id += alphabet[bytes[j] & mask] || ''\n        if (id.length === size) return id\n      }\n    }\n  }\n}\n\nlet customAlphabet = (alphabet, size) => customRandom(alphabet, size, random)\n\nlet nanoid = (size = 21) => {\n  let id = ''\n  let bytes = crypto.getRandomValues(new Uint8Array(size))\n\n  // A compact alternative for `for (var i = 0; i < step; i++)`.\n  while (size--) {\n    // It is incorrect to use bytes exceeding the alphabet size.\n    // The following mask reduces the random byte in the 0-255 value\n    // range to the 0-63 value range. Therefore, adding hacks, such\n    // as empty string fallback or magic numbers, is unneccessary because\n    // the bitmask trims bytes down to the alphabet size.\n    let byte = bytes[size] & 63\n    if (byte < 36) {\n      // `0-9a-z`\n      id += byte.toString(36)\n    } else if (byte < 62) {\n      // `A-Z`\n      id += (byte - 26).toString(36).toUpperCase()\n    } else if (byte < 63) {\n      id += '_'\n    } else {\n      id += '-'\n    }\n  }\n  return id\n}\n\nexport { nanoid, customAlphabet, customRandom, urlAlphabet, random }\n","import React, { Component } from 'react';\nimport { connect } from 'react-redux';\nimport { addContact, getItems } from '../../redux/contacts';\nimport PropTypes from 'prop-types';\nimport { nanoid } from 'nanoid'\n\nclass ContactForm extends Component {\n  static propTypes = {\n    name: PropTypes.string,\n    number: PropTypes.string,\n  };\n\n  state = {\n    name: '',\n    number: '',\n  };\n    \n  loginInputNameId = nanoid(); \n  loginInputNamberId = nanoid(); \n  \n  hendleInputChange = event => {\n    const { name, value } = event.currentTarget;\n\n    this.setState({ [name]: value });\n  };\n\n  handleSubmit = event => {\n    event.preventDefault();\n\n    const addInputValue = contact =>\n      contact.name === this.state.name || contact.number === this.state.number;\n\n    if (this.props.items.some(addInputValue)) {\n      alert(`Contact is already in contacts`);\n      return;\n    }\n\n    this.props.onSubmit({...this.state})\n    this.reset()\n  };\n    \n  reset = () => {\n    this.setState({ name: '', number: '' })\n  };\n  \n  render() {\n    const { name, number } = this.state;\n      \n    return (\n      <section className=\"sectionFormContacts\">\n        <form onSubmit = {this.handleSubmit}>\n          <label htmlFor={this.loginInputNameId}>Name</label>\n          \n          <input\n            type=\"text\"\n            name=\"name\"\n            pattern=\"^[a-zA-Zа-яА-Я]+(([' -][a-zA-Zа-яА-Я ])?[a-zA-Zа-яА-Я]*)*$\"\n            title=\"Имя может состоять только из букв, апострофа, тире и пробелов. Например Adrian, Jacob Mercer, Charles de Batz de Castelmore d'Artagnan и т. п.\"\n            required\n            id = {this.loginInputNameId}\n            value={name}\n            onChange = {this.hendleInputChange}\n                \n          />\n        \n\n          <label htmlFor={this.loginInputNamberId}>Number</label>\n          \n          <input\n            type=\"tel\"\n            name=\"number\"\n            pattern=\"\\+?\\d{1,4}?[-.\\s]?\\(?\\d{1,3}?\\)?[-.\\s]?\\d{1,4}[-.\\s]?\\d{1,4}[-.\\s]?\\d{1,9}\"\n            title=\"Номер телефона должен состоять из цифр и может содержать пробелы, тире, круглые скобки и может начинаться с +\"\n            required\n            id = {this.loginInputNamberId}\n            value={number}\n            onChange = {this.hendleInputChange}\n          />\n        \n                  \n          <button type=\"submit\" className=\"btn btnForm\">Add contact</button>\n        </form>\n      </section>\n\n    )\n  }\n}\n\nconst mapStateToProps = state => ({\n  items: getItems(state),\n});\n\nconst mapDispatchFromProps = dispatch => ({\n  onSubmit: ({ name, number }) => dispatch(addContact({ name, number })),\n});\n\nexport default connect(mapStateToProps, mapDispatchFromProps)(ContactForm);\n","import PropTypes from 'prop-types';\n\nconst ContactList = ({ children }) => (\n  <ul className=\"contactList\">{children}</ul>\n);\n\nContactList.propTypes = {\n  children: PropTypes.node,\n};\n\nexport default ContactList;\n\n","import PropTypes from 'prop-types';\nimport { connect } from 'react-redux';\nimport { deleteContact, getFilteredContactList } from '../../redux/contacts';\n\nconst ContactItem = ({ onDelete, contactsItems }) => (\n  <>\n    {contactsItems.map(({ id, name, number }) => {\n      return (\n        <li key={id}>\n          <p>{`${name}: ${number}`}</p>\n          <button type=\"button\" onClick={() => onDelete(id)} className=\"btn\">\n            Delete\n          </button>\n        </li>\n      );\n    })}\n  </>\n);\n\nconst mapStateToProps = state => ({\n  contactsItems: getFilteredContactList(state),\n});\n\nconst mapDispatchFromProps = dispatch => ({\n  onDelete: id => dispatch(deleteContact(id)),\n});\n\nexport default connect(mapStateToProps, mapDispatchFromProps)(ContactItem);\n\n\nContactItem.propTypes = {\n  contacts: PropTypes.arrayOf(\n    PropTypes.shape({\n      id: PropTypes.string.isRequired,\n      name: PropTypes.string.isRequired,\n      number: PropTypes.string.isRequired,\n    }),\n  ),\n  onDelete: PropTypes.func,\n};","import { connect } from 'react-redux';\nimport { changeFilter, getFilterValue } from '../../redux/contacts';\n\nconst Filter = ({ value, onChange }) => (\n  <label className=\"filter\">\n    Find contacts by name\n    <div >\n      <input type=\"text\" value={value} onChange={onChange}></input>\n    </div>\n    \n  </label>\n);\n\nconst mapStateToProps = state => ({\n  value: getFilterValue(state),\n});\n\nconst mapDispatchFromProps = dispatch => ({\n  onChange: event => dispatch(changeFilter(event.target.value)),\n});\n\nexport default connect(mapStateToProps, mapDispatchFromProps)(Filter);\n\n","import React, {Component} from 'react';\nimport { connect, } from 'react-redux';\n\nimport ContactForm from '../components/ContactForm'\nimport ContactList from '../components/ContactList'\nimport ContactItem from '../components/ContactItem';\nimport Filter from '../components/Filter'\n\nimport { fetchContacts } from '../redux/contacts/contacts-operations';\nimport { getItems, getLoadingItems } from '../redux/contacts/contacts-selectors';\n\nclass ContactsView extends Component {\n  componentDidMount() {\n    this.props.fetchItems();\n  }\n\n  render() {\n    return (\n      <>\n        <h1>Phonebook</h1>\n        <ContactForm/>\n        <h2>Contacts</h2>\n  \n        {this.props.items.length > 0 ? (\n          <>\n            <Filter />\n            <ContactList>\n              <ContactItem />\n            </ContactList>\n          </>\n        ) : (\n          <span>You have no contacts!</span>\n        )}\n      </>\n    )\n  }\n};\n\n\nconst mapStateToProps = state => ({\n  items: getItems(state),\n  isLoading: getLoadingItems(state),\n});\n\nconst mapDispatchToProps = dispatch => ({\n  fetchItems: () => dispatch(fetchContacts()),\n});\n\nexport default connect(mapStateToProps, mapDispatchToProps)(ContactsView);"],"sourceRoot":""}